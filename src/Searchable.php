<?php

namespace Daalvand\LaravelElasticsearch;

use Closure;
use Exception;
use Illuminate\Database\Eloquent\Builder as BaseEloquentBuilder;
use Illuminate\Database\Query\Builder as BaseBuilder;
use Illuminate\Support\Collection as SupportCollection;
use Illuminate\Support\Str;

/**
 * Trait Searchable
 * @method string|null getConnectionName()
 * @method string getTable()
 * @method array toArray()
 * @method array getArrayableRelations()
 * @method static EloquentBuilder on(?string $connection = null)
 * @package Daalvand\LaravelElasticsearch
 */
trait Searchable
{
    public function getElasticsearchConnectionName(): string
    {
        if ($this->driverIsElasticsearch()) {
            return $this->getConnection()->getName();
        }
        return 'elasticsearch';
    }

    public function elasticDriver(): string
    {
        return 'elasticsearch';
    }


    /**
     * Begin querying the model.
     *
     * @return Builder
     */
    public static function query()
    {
        /** @noinspection PhpIncompatibleReturnTypeInspection */
        return parent::query();
    }

    /**
     * Get a new query builder for the model's table.
     *
     * @return Builder
     */
    public function newQuery()
    {
        /** @noinspection PhpIncompatibleReturnTypeInspection */
        return parent::newQuery(); // TODO: Change the autogenerated stub
    }

    /**
     * Get the index this model is to be added to
     *
     * @return string
     */
    public function getSearchIndex()
    {
        return $this->searchIndex ?? $this->getTable();
    }

    /**
     * Set the index this model is to be added to
     *
     * @param string
     * @return self
     */
    public function setSearchIndex(string $index)
    {
        $this->searchIndex = $index;

        return $this;
    }

    /**
     * Get the search type associated with the model.
     *
     * @return string
     */
    public function getSearchType()
    {
        return $this->searchType ?? Str::singular($this->getTable());
    }

    /**
     * Carry out the given function on the search connection
     *
     * @param Closure $callback
     * @return mixed
     */
    public function onSearchConnection(Closure $callback)
    {
        $arguments = array_slice(func_get_args(), 1);

        $elasticModel = clone $arguments[0];
        $elasticModel->setConnection($this->getElasticsearchConnectionName());

        $arguments[0] = $elasticModel;

        return $callback(...$arguments);
    }

    /**
     * Implementing models can override this method to set additional query
     * parameters to be used when searching
     *
     * @param EloquentBuilder $query
     * @return EloquentBuilder
     */
    public function setKeysForSearch($query)
    {
        return $query;
    }

    /**
     * Add to search index
     *
     * @return bool
     * @throws Exception
     */
    public function addToIndex()
    {
        return $this->onSearchConnection(function ($model) {
            $query = $model->setKeysForSaveQuery($model->newQueryWithoutScopes());

            $model->setKeysForSearch($query);

            return $query->insert($model->toSearchableArray());
        }, $this);
    }

    /**
     * Update indexed document
     *
     * @return bool
     * @throws Exception
     */
    public function updateIndex()
    {
        return $this->addToIndex();
    }

    /**
     * Remove from search index
     *
     * @return bool
     */
    public function removeFromIndex()
    {
        return $this->onSearchConnection(function ($model) {
            $query = $model->setKeysForSaveQuery($model->newQueryWithoutScopes());

            $model->setKeysForSearch($query);

            return $query->delete();
        }, $this);
    }

    /**
     * Create a searchable version of this model
     *
     * @return array
     */
    public function toSearchableArray()
    {
        // Run this on the search connection if it's not the current connection
        if ($this->driverIsElasticsearch()) {
            return $this->onSearchConnection(function ($model) {
                return $model->toSearchableArray();
            }, $this);
        }

        $array = $this->toArray();

        foreach ($this->getArrayableRelations() as $key => $relation) {
            $attributeName = Str::snake($key);

            if (isset($array[$attributeName]) && method_exists($relation, 'toSearchableArray')) {
                $array[$attributeName] = $relation->onSearchConnection(function ($model) {
                    return $model->toSearchableArray();
                }, $relation);
            } elseif (isset($array[$attributeName]) && $relation instanceof SupportCollection) {
                $array[$attributeName] = $relation->map(function ($item) {
                    if (method_exists($item, 'toSearchableArray')) {
                        return $item->onSearchConnection(function ($model) {
                            return $model->toSearchableArray();
                        }, $item);
                    }

                    return $item;
                })->all();
            }
        }

        $array['id'] = $this->id;

        unset($array['_id']);

        foreach ((array)$this->indexAsChildDocuments as $field) {
            $subDocuments = $this->$field ?? [];

            foreach ($subDocuments as $subDocument) {
                $array['child_documents'][] = $this->onSearchConnection(function ($model) {
                    return $model->getSubDocumentIndexData($model);
                }, $subDocument);
            }
        }

        return $array;
    }

    /**
     * Build index details for a sub document
     *
     * @param Model $document
     * @return array
     */
    public function getSubDocumentIndexData($document)
    {
        return [
            'type'     => $document->getSearchType(),
            'id'       => $document->id,
            'document' => $document->toSearchableArray()
        ];
    }

    /**
     * New Collection
     *
     * @param array $models
     * @return Collection
     */
    public function newCollection(array $models = [])
    {
        return new Collection($models);
    }

    /**
     * @return EloquentBuilder
     */
    public function newElasticsearchQuery(): EloquentBuilder
    {
        return $this->on($this->getElasticsearchConnectionName());
    }

    /**
     * Create a new Eloquent builder for the model.
     *
     * @param BaseBuilder $query
     * @return BaseEloquentBuilder|EloquentBuilder
     */
    public function newEloquentBuilder($query)
    {
        if ($this->driverIsElasticsearch()) {
            return new EloquentBuilder($query);
        }
        return new BaseEloquentBuilder($query);
    }

    /**
     * Get a new query builder instance for the connection.
     *
     * @return BaseBuilder|Builder
     */
    protected function newBaseQueryBuilder()
    {
        $connection = $this->getConnection();
        if ($this->driverIsElasticsearch()) {
            return new Builder($connection, $connection->getQueryGrammar(), $connection->getPostProcessor());
        }
        return new BaseBuilder($connection, $connection->getQueryGrammar(), $connection->getPostProcessor());
    }


    /**
     * Qualify the given column name by the model's table.
     *
     * @param string $column
     * @return string
     */
    public function qualifyColumn($column)
    {
        if ($this->driverIsElasticsearch()) {
            return $column;
        }
        return parent::qualifyColumn($column);
    }

    /**
     * @return bool
     */
    protected function driverIsElasticsearch(): bool
    {
        return $this->getConnection()->getConfig('driver') !== $this->elasticDriver();
    }
}
